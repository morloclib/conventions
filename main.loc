module conventions (*)

{-

This package is too big. It is hard to draw a line at what fits in and what
doesn't. So much depends on domain. So it may make more sense to break
everything down into smaller packages.

 * math
 * stat
 * ml
 * combinators
 * containers
   * list
   * tuple
   * map
   * set
   * maybe
   * either
 * binary
 * string
 * text

-}

------------- Effects
sleep :: Real -> a -> a

------------- Control
ifelse :: Bool -> a -> a -> a

------------- Combinators and functions
id :: a -> a
seq :: a -> b -> b
const :: a -> b -> a
fst :: (a, b) -> a
snd :: (a, b) -> b
tuple :: a -> b -> (a, b)
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
onSnd :: (b -> b') -> (a, b) -> (a, b')
onFst :: (a -> a') -> (a, b) -> (a', b)
toSnd :: (a -> b) -> a -> (a, b)
toFst :: (a -> b) -> a -> (b, a)

------------- Strings
show :: a -> Str
unlines :: [Str] -> Str
words :: Str -> [Str]
unwords :: [Str] -> Str
lines :: Str -> [Str]
lengthS :: Str -> Int



------------- Lists
-- -- Laws
-- withVals id xs == xs
-- withKeys id xs == xs
-- mapVal id xs == xs
-- mapKey id xs == xs
-- filterVal true xs == xs
-- filterVal false xs == []

at :: [a] -> Int -> a
break :: (a -> Bool) -> [a] -> ([a], [a])
concat :: [[a]] -> [a]
concatMap :: (a -> [b]) -> [a] -> [b]
contextFilterKey :: (a -> b -> (a, Bool)) -> a -> [(b,c)] -> [(b,c)]
contextFilterVal :: (a -> b -> (a, Bool)) -> a -> [(c,b)] -> [(c,b)]
drop :: Int -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
enumerateWith :: (a -> Int -> b) -> [a] -> [b]
flip :: (a -> b -> c) -> b -> a -> c
fold :: (b -> a -> b) -> b -> [a] -> b
get :: Int -> [a] -> a -- get 1 [1,2,3] => 2
head :: [a] -> a -- [1,2,3] => 1
init :: [a] -> [a] -- [1,2,3] => [1,2]
join :: [a] -> [a] -> [a]
cons :: a -> [a] -> [a]
last :: [a] -> a -- [1,2,3] => 3
length :: [a] -> Int
lookup :: k -> [(k, v)] -> v
map :: (a -> b) -> [a] -> [b]
replicate :: Int -> a -> [a]
reverse :: [a] -> [a]
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
shard :: Int -> [a] -> [[a]]
span :: (a -> Bool) -> [a] -> ([a], [a])
splitAt :: Int -> [a] -> ([a], [a])
tail :: [a] -> [a] -- [1,2,3] => [2,3]
take :: Int -> [a] -> [a]
takeWhile :: (a -> Bool) -> [a] -> [a]
unique :: [a] -> [a]
until :: (a -> Bool) -> (a -> a) -> a -> a
unzip :: [(a, b)] -> ([a], [b])
withFsts :: ([a] -> [b]) -> [(a, c)] -> [(b, c)]
withSnds :: ([a] -> [b]) -> [(c, a)] -> [(c, b)]
zip :: [a] -> [b] -> [(a, b)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
elem :: a -> [a] -> Bool

------------- Maps

keys :: Map a b -> [a]
vals :: Map a b -> [b]
mapKey :: (a -> a') -> Map a b -> Map a' b 
mapVal :: (b -> b') -> Map a b -> Map a b'
filterKey :: (k -> Bool) -> Map k v -> Map k v
filterVal :: (v -> Bool) -> Map k v -> Map k v
readMap :: Filename -> Map key val

------------- Arithmetic and Comparisons

-- NOTE: After a system for numeric casting is added to morloc, replace the
-- concrete arithmetic operators below with qualified types, e.g.:
-- add :: Real -> Real -> Real
-- add Cpp :: a -> a -> a
-- Or maybe
-- add Cpp :: a -> b -> c
-- So this is complicated ... if the two inputs to add can be of different
-- types, say int and double, then what is the return type? For add, the return
-- type would need to be decided based on a function of the input types. But these
-- types will depend on the function. I will need to research this problem ...
--
-- As a temporary measure, I will leave the types as "double". On the C++ side
-- in core.hpp, they are all implemented as fully generalized templates of three
-- independent types.

-- arithmetic operators - these are all currently limited to reals. Integers are
-- not supported. That is embarrassing. I really really need typeclasses.

add :: Real -> Real -> Real
sub :: Real -> Real -> Real
mul :: Real -> Real -> Real
div :: Real -> Real -> Real
mod :: Real -> Real -> Real
neg :: Real -> Real

--- TODO: these too specific, being limited to integers, need typeclasses!!!
gt :: Int -> Int -> Bool
lt :: Int -> Int -> Bool
eq :: Int -> Int -> Bool
ne :: Int -> Int -> Bool
