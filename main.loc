module conventions

{-

This module is too big. Should there really be a prelude? What does everyone
ALWAYS need? Also, learn from Haskell, avoid prelude commitment and the string
problem.

So what modules might I make?

  text
  byte
  list
  comb
  func
  ...

And so on, but now I have a partioning problem leading to the annoying issue of
remembering which module contains which functionallity. The problem is that
classification is not so clear. A function like "lookup" may be have
implementations for pair lists and maps and data bases. It generalizes the idea
of `f k a -> k -> ?a`, where `?` is my standin for `Maybe`.

-}

-- I really need to implement `export *` syntax
export add
export at
export break
export concat
export concatMap
export contextFilterKey
export contextFilterVal
export curry
export div
export drop
export dropWhile
export elem
export enumerateWith
export filterKey
export filterVal
export flip
export fold
export fst
export get
export gt
export head
export id
export ifelse
export init
export join
export keys
export last
export length
export lines
export lookup
export map
export mapFst
export mapKey
export onSnd
export mapVal
export mod
export mul
export neg
export onFst
export readMap
export replicate
export reverse
export scanl
export scanl1
export scanr
export scanr1
export seq
export shard
export show
export sleep
export snd
export span
export splitAt
export strLength
export sub
export tail
export take
export takeWhile
export toFst
export toSnd
export tuple
export uncurry
export unique
export unlines
export until
export unwords
export unzip
export vals
export withKeys
export withVals
export words
export zip
export zipWith
export gt
export lt
export eq
export ne


------------- Effects
sleep :: Real -> a -> a

------------- Control
ifelse :: Bool -> a -> a -> a

------------- Combinators and functions
id :: a -> a
seq :: a -> b -> b
const :: a -> b -> a
fst :: (a, b) -> a
snd :: (a, b) -> b
tuple :: a -> b -> (a, b)
curry :: ((a, b) -> c) -> a -> b -> c
uncurry :: (a -> b -> c) -> (a, b) -> c
onSnd :: (b -> b') -> (a, b) -> (a, b')
onFst :: (a -> a') -> (a, b) -> (a', b)
toSnd :: (a -> b) -> a -> (a, b)
toFst :: (a -> b) -> a -> (b, a)

------------- Strings
show :: a -> Str
unlines :: [Str] -> Str
words :: Str -> [Str]
unwords :: [Str] -> Str
lines :: Str -> [Str]
strLength :: Str -> Int



------------- Lists
-- -- Laws
-- withVals id xs == xs
-- withKeys id xs == xs
-- mapVal id xs == xs
-- mapKey id xs == xs
-- filterVal true xs == xs
-- filterVal false xs == []
-- filterKey true xs == xs
-- filterKey false xs == []

at :: [a] -> Int -> a
break :: (a -> Bool) -> [a] -> ([a], [a])
concat :: [[a]] -> [a]
concatMap :: (a -> [b]) -> [a] -> [b]
contextFilterKey :: (a -> b -> (a, Bool)) -> a -> [(b,c)] -> [(b,c)]
contextFilterVal :: (a -> b -> (a, Bool)) -> a -> [(c,b)] -> [(c,b)]
drop :: Int -> [a] -> [a]
dropWhile :: (a -> Bool) -> [a] -> [a]
enumerateWith :: (a -> Int -> b) -> [a] -> [b]
filterKey :: (a -> Bool) -> [(a, b)] -> [(a, b)]
filterVal :: (b -> Bool) -> [(a, b)] -> [(a, b)]
flip :: (a -> b -> c) -> b -> a -> c
fold :: (b -> a -> b) -> b -> [a] -> b
get :: Int -> [a] -> a -- get 1 [1,2,3] => 2
head :: [a] -> a -- [1,2,3] => 1
init :: [a] -> [a] -- [1,2,3] => [1,2]
join :: [a] -> [a] -> [a]
last :: [a] -> a -- [1,2,3] => 3
length :: [a] -> Int
lookup :: k -> [(k, v)] -> v
map :: (a -> b) -> [a] -> [b]
mapKey :: (a -> b) -> [(a, c)] -> [(b, c)]
mapVal :: (a -> b) -> [(c, a)] -> [(c, b)]
replicate :: Int -> a -> [a]
reverse :: [a] -> [a]
scanl :: (b -> a -> b) -> b -> [a] -> [b]
scanl1 :: (a -> a -> a) -> [a] -> [a]
scanr :: (a -> b -> b) -> b -> [a] -> [b]
scanr1 :: (a -> a -> a) -> [a] -> [a]
shard :: Int -> [a] -> [[a]]
span :: (a -> Bool) -> [a] -> ([a], [a])
splitAt :: Int -> [a] -> ([a], [a])
tail :: [a] -> [a] -- [1,2,3] => [2,3]
take :: Int -> [a] -> [a]
takeWhile :: (a -> Bool) -> [a] -> [a]
unique :: [a] -> [a]
until :: (a -> Bool) -> (a -> a) -> a -> a
unzip :: [(a, b)] -> ([a], [b])
withKeys :: ([a] -> [b]) -> [(a, c)] -> [(b, c)]
withVals :: ([a] -> [b]) -> [(c, a)] -> [(c, b)]
zip :: [a] -> [b] -> [(a, b)]
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
elem :: a -> [a] -> Bool


withKeys f xs = zip (f (map fst xs)) (map snd xs)

------------- Maps

keys :: Map a b -> [a]
vals :: Map a b -> [b]
mapKeys :: (a -> a') -> Map a b -> Map a' b 
mapVals :: (b -> b') -> Map a b -> Map a b'
readMap :: Filename -> Map key val

------------- Arithmetic and Comparisons

-- NOTE: After a system for numeric casting is added to morloc, replace the
-- concrete arithmetic operators below with qualified types, e.g.:
-- add :: Real -> Real -> Real
-- add Cpp :: a -> a -> a
-- Or maybe
-- add Cpp :: a -> b -> c
-- So this is complicated ... if the two inputs to add can be of different
-- types, say int and double, then what is the return type? For add, the return
-- type would need to be decided based on a function of the input types. But these
-- types will depend on the function. I will need to research this problem ...
--
-- As a temporary measure, I will leave the types as "double". On the C++ side
-- in core.hpp, they are all implemented as fully generalized templates of three
-- independent types.

-- arithmetic operators - these are all currently limited to reals. Integers are
-- not supported. That is embarrassing. I really really need typeclasses.

add :: Real -> Real -> Real
sub :: Real -> Real -> Real
mul :: Real -> Real -> Real
div :: Real -> Real -> Real
mod :: Real -> Real -> Real
neg :: Real -> Real

--- TODO: these too specific, being limited to integers, need typeclasses!!!
gt :: Int -> Int -> Bool
lt :: Int -> Int -> Bool
eq :: Int -> Int -> Bool
ne :: Int -> Int -> Bool
